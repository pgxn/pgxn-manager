SET search_path = public,contrib,tap;

BEGIN;
SELECT plan(99);
--SELECT * FROM no_plan();

/****************************************************************************/
-- Assertion function for validating JSON.
CREATE OR REPLACE FUNCTION json_ok(
    json  TEXT,
    descr TEXT
) RETURNS TEXT LANGUAGE plperl AS $$
    eval { JSON::XS->new->decode(shift) };
    my $ok = sub {
        my ($bool, $descr, $diag) = @_;
        my $ret = spi_exec_query(
            sprintf 'SELECT ok(%s, %s)', $bool, quote_nullable($descr)
        )->{rows}[0]{ok};
        $ret .= "\n" . spi_exec_query(
            sprintf 'SELECT diag(%s)', quote_nullable("    Error: $diag")
        )->{rows}[0]{diag} if $diag;
        return $ret;
    };
    if (my $e = $@) {
        return $ok->('false', shift, $e);
    } else {
        return $ok->('true', shift);
    }
$$;

/****************************************************************************/
-- Test munge_email().

SELECT has_function(    'munge_email' );
SELECT has_function(    'munge_email', ARRAY['email'] );
SELECT function_returns('munge_email', ARRAY['email'], 'text' );
SELECT function_lang_is('munge_email', ARRAY['email'], 'plpgsql' );
SELECT is_strict(       'munge_email', ARRAY['email'] );
SELECT volatility_is(   'munge_email', ARRAY['email'], 'immutable' );
SELECT ok(
    has_function_privilege('pgxn', 'munge_email(email)', 'EXECUTE'),
    'User "pgxn" should have EXECUTE priv on munge_email()'
);

SELECT is( munge_email('foo@bar.com'), 'bar.com|foo', 'munge_email(email)');
SELECT is( munge_email(NULL), NULL, 'munge_email(NULL)');

/****************************************************************************/
-- Test get_mirrors_json().

SELECT has_function(    'get_mirrors_json' );
SELECT has_function(    'get_mirrors_json', '{}'::text[] );
SELECT function_returns('get_mirrors_json', 'text' );
SELECT function_lang_is('get_mirrors_json', 'sql' );
SELECT volatility_is(   'get_mirrors_json', 'stable' );
SELECT is_strict(       'get_mirrors_json', 'stable' );
SELECT ok(
    has_function_privilege('pgxn', 'get_mirrors_json()', 'EXECUTE'),
    'User "pgxn" should have EXECUTE priv on get_mirrors_json()'
);

SELECT is(
    get_mirrors_json(),
    E'[\n   \n]\n',
    'Should get empty JSON array with no mirrors'
);

SELECT json_ok(get_mirrors_json(), 'Empty JSON array should be valid');

SELECT ok(
    insert_user('theory', 'wet blanket', email := 'theory@pgxn.org', uri := 'http://justatheory.com/'),
    'Insert user "theory"'
);
UPDATE users SET is_admin = true WHERE nickname = 'theory';

SELECT ok(
    insert_mirror(
        'theory',
        uri          := 'http://example.com/pgxn/',
        frequency    := 'hourly',
        location     := 'Portland, OR, USA',
        bandwidth    := '10MBps',
        organization := 'Kineticode, Inc.',
        timezone     := 'America/Los_Angeles',
        email        := 'pgxn@example.com',
        src          := 'rsync://master.pgxn.org/pgxn/'
    ), 'Insert a mirror'
);

SELECT is(
    get_mirrors_json(),
    '[
   {
      "uri": "http://example.com/pgxn/",
      "frequency": "hourly",
      "location": "Portland, OR, USA",
      "organization": "Kineticode, Inc.",
      "timezone": "America/Los_Angeles",
      "email": "example.com|pgxn",
      "bandwidth": "10MBps",
      "src": "rsync://master.pgxn.org/pgxn/"
   }
]
',
    'Should get single-item JSON array with one mirror'
);

SELECT json_ok(get_mirrors_json(), 'Single-item mirror JSON should be valid');

-- Add another mirror with rsync and notes keys.
SELECT ok(
    insert_mirror(
        'theory',
        uri          := 'http://pgxn.example.net/',
        frequency    := 'daily',
        location     := 'Portland, OR, USA',
        bandwidth    := 'Cable',
        organization := 'David E. Wheeler',
        timezone     := 'America/Los_Angeles',
        email        := 'pgxn@example.net',
        src          := 'rsync://master.pgxn.org/pgxn/',
        rsync        := 'rsync://master.pgxn.org/pgxn/',
        notes        := 'These be some notes, yo'
    ), 'Insert a mirror'
);

-- Ensure the display order.
UPDATE mirrors SET created_at = NOW() - '1 day'::interval
 WHERE uri = 'http://example.com/pgxn/';

SELECT is(
    get_mirrors_json(),
    '[
   {
      "uri": "http://example.com/pgxn/",
      "frequency": "hourly",
      "location": "Portland, OR, USA",
      "organization": "Kineticode, Inc.",
      "timezone": "America/Los_Angeles",
      "email": "example.com|pgxn",
      "bandwidth": "10MBps",
      "src": "rsync://master.pgxn.org/pgxn/"
   },
   {
      "uri": "http://pgxn.example.net/",
      "frequency": "daily",
      "location": "Portland, OR, USA",
      "organization": "David E. Wheeler",
      "timezone": "America/Los_Angeles",
      "email": "example.net|pgxn",
      "bandwidth": "Cable",
      "src": "rsync://master.pgxn.org/pgxn/",
      "rsync": "rsync://master.pgxn.org/pgxn/",
      "notes": "These be some notes, yo"
   }
]
',
    'Should get two-item-item JSON array with two mirrors'
);

SELECT json_ok(get_mirrors_json(), 'Two-item mirror JSON should be valid');

/****************************************************************************/
-- Test extension_json().

SELECT has_function(    'extension_json' );
SELECT has_function(    'extension_json', ARRAY['text', 'semver'] );
SELECT function_returns('extension_json', ARRAY['text', 'semver'], 'setof record' );
SELECT function_lang_is('extension_json', ARRAY['text', 'semver'], 'plpgsql' );
SELECT volatility_is(   'extension_json', ARRAY['text', 'semver'], 'stable' );
SELECT is_strict(       'extension_json', ARRAY['text', 'semver'] );
SELECT ok(
    has_function_privilege('pgxn', 'extension_json(text, semver)', 'EXECUTE'),
    'User "pgxn" should have EXECUTE priv on extension_json()'
);

SELECT is_empty(
    $$ SELECT * FROM extension_json(NULL, NULL) $$,
    'Should get no results from extension_json() when no extensions'
);

-- Let's create a distribution.
SELECT lives_ok(
     $$ SELECT * FROM add_distribution('theory', 'pshaw', '{
        "name": "pair",
        "version": "0.0.01",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Ordered pair",
        "provides": {
            "pair": { "file": "pair.sql.in", "version": "0.02.02" },
            "trip": { "file": "trip.sql.in", "version": "0.02.01" }
        },
        "release_status": "testing"
    }')$$,
    'Add a testing distribution'
);

SELECT results_eq(
    $$ SELECT * FROM extension_json('pair', '0.0.1') $$,
    $$ VALUES
        ('pair'::citext, '{
   "extension": "pair",
   "latest": "testing",
   "testing": { "dist": "pair", "version": "0.0.1", "sha1": "pshaw" },
   "versions": {
      "0.2.2": [
         { "dist": "pair", "version": "0.0.1", "status": "testing" }
      ]
   }
}
'),
        ('trip', '{
   "extension": "trip",
   "latest": "testing",
   "testing": { "dist": "pair", "version": "0.0.1", "sha1": "pshaw" },
   "versions": {
      "0.2.1": [
         { "dist": "pair", "version": "0.0.1", "status": "testing" }
      ]
   }
}
')
    $$,
    'Should get proper data for extensions in a single distribution'
);

-- Add an unstable distribution.
SELECT lives_ok(
     $$ SELECT * FROM add_distribution('theory', 'pshaw', '{
        "name": "pair",
        "version": "0.0.2a1",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Ordered pair",
        "provides": {
            "pair": { "file": "pair.sql.in", "version": "0.02.03" },
            "trip": { "file": "trip.sql.in", "version": "0.02.02" }
        },
        "release_status": "unstable"
    }') $$,
    'Add an unstable distribution'
);

SELECT results_eq(
    $$ SELECT * FROM extension_json('pair', '0.0.2a1') $$,
    $$ VALUES
        ('pair'::citext, '{
   "extension": "pair",
   "latest": "unstable",
   "testing": { "dist": "pair", "version": "0.0.1", "sha1": "pshaw" },
   "unstable": { "dist": "pair", "version": "0.0.2a1", "sha1": "pshaw" },
   "versions": {
      "0.2.3": [
         { "dist": "pair", "version": "0.0.2a1", "status": "unstable" }
      ],
      "0.2.2": [
         { "dist": "pair", "version": "0.0.1", "status": "testing" }
      ]
   }
}
'),
        ('trip', '{
   "extension": "trip",
   "latest": "unstable",
   "testing": { "dist": "pair", "version": "0.0.1", "sha1": "pshaw" },
   "unstable": { "dist": "pair", "version": "0.0.2a1", "sha1": "pshaw" },
   "versions": {
      "0.2.2": [
         { "dist": "pair", "version": "0.0.2a1", "status": "unstable" }
      ],
      "0.2.1": [
         { "dist": "pair", "version": "0.0.1", "status": "testing" }
      ]
   }
}
')
    $$,
    'Should get proper data for extensions in testing and unstable distributions'
);

-- Add a stable distribution.
SELECT lives_ok(
     $$ SELECT * FROM add_distribution('theory', 'pshaw', '{
        "name": "pair",
        "version": "0.0.2",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Ordered pair",
        "provides": {
            "pair": { "file": "pair.sql.in", "version": "0.2.4" },
            "trip": { "file": "trip.sql.in", "version": "0.2.3" }
        }
    }') $$,
    'Add a stable distribution'
);

SELECT results_eq(
    $$ SELECT * FROM extension_json('pair', '0.0.2') $$,
    $$ VALUES
        ('pair'::citext, '{
   "extension": "pair",
   "latest": "stable",
   "stable": { "dist": "pair", "version": "0.0.2", "sha1": "pshaw" },
   "testing": { "dist": "pair", "version": "0.0.1", "sha1": "pshaw" },
   "unstable": { "dist": "pair", "version": "0.0.2a1", "sha1": "pshaw" },
   "versions": {
      "0.2.4": [
         { "dist": "pair", "version": "0.0.2" }
      ],
      "0.2.3": [
         { "dist": "pair", "version": "0.0.2a1", "status": "unstable" }
      ],
      "0.2.2": [
         { "dist": "pair", "version": "0.0.1", "status": "testing" }
      ]
   }
}
'),
        ('trip', '{
   "extension": "trip",
   "latest": "stable",
   "stable": { "dist": "pair", "version": "0.0.2", "sha1": "pshaw" },
   "testing": { "dist": "pair", "version": "0.0.1", "sha1": "pshaw" },
   "unstable": { "dist": "pair", "version": "0.0.2a1", "sha1": "pshaw" },
   "versions": {
      "0.2.3": [
         { "dist": "pair", "version": "0.0.2" }
      ],
      "0.2.2": [
         { "dist": "pair", "version": "0.0.2a1", "status": "unstable" }
      ],
      "0.2.1": [
         { "dist": "pair", "version": "0.0.1", "status": "testing" }
      ]
   }
}
')
    $$,
    'Should get proper data for extensions in multiple distributions'
);

SELECT json_ok(json, 'JSON for extension ' || extension || ' should be valid')
  FROM extension_json('pair', '0.0.2');

-- Now have strongrrl do a release with only the "trip" type.
SELECT ok(
    insert_user('strongrrl', 'wet blanket', email := 'strongrrl@pgxn.org', twitter := 'strongrrl'),
    'Insert user "strongrrl"'
);

UPDATE users SET status = 'active';
INSERT INTO coowners (extension, nickname) VALUES ('trip', 'strongrrl');

SELECT lives_ok(
     $$ SELECT * FROM add_distribution('strongrrl', 'pshaw', '{
        "name": "trip",
        "version": "0.2.5",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Ordered triplet"
    }') $$,
    'Add a trip distribution'
);

SELECT results_eq(
    $$ SELECT * FROM extension_json('trip', '0.2.5') $$,
    $$ VALUES
        ('trip'::citext, '{
   "extension": "trip",
   "latest": "stable",
   "stable": { "dist": "trip", "version": "0.2.5", "sha1": "pshaw" },
   "testing": { "dist": "pair", "version": "0.0.1", "sha1": "pshaw" },
   "unstable": { "dist": "pair", "version": "0.0.2a1", "sha1": "pshaw" },
   "versions": {
      "0.2.5": [
         { "dist": "trip", "version": "0.2.5" }
      ],
      "0.2.3": [
         { "dist": "pair", "version": "0.0.2" }
      ],
      "0.2.2": [
         { "dist": "pair", "version": "0.0.2a1", "status": "unstable" }
      ],
      "0.2.1": [
         { "dist": "pair", "version": "0.0.1", "status": "testing" }
      ]
   }
}
')
    $$,
    'Should get proper data for extensions in the "trip" distribution'
);

SELECT json_ok(json, 'JSON for extension ' || extension || ' should be valid')
  FROM extension_json('trip', '0.2.5');

-- Great, now do a release with dup versions of both extensions.
SELECT lives_ok(
     $$ SELECT * FROM add_distribution('theory', 'rickshaw', '{
        "name": "pair",
        "version": "0.0.3",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Ordered pair",
        "provides": {
            "pair": { "file": "pair.sql.in", "version": "0.2.4" },
            "trip": { "file": "trip.sql.in", "version": "0.2.5" }
        }
    }') $$,
    'Add a distribution with dupe extension versions'
);

UPDATE distributions SET created_at = created_at + '1 day'::interval WHERE name = 'pair' AND VERSION = '0.0.3';

SELECT results_eq(
    $$ SELECT * FROM extension_json('pair', '0.0.3') $$,
    $$ VALUES
        ('pair'::citext, '{
   "extension": "pair",
   "latest": "stable",
   "stable": { "dist": "pair", "version": "0.0.3", "sha1": "rickshaw" },
   "testing": { "dist": "pair", "version": "0.0.1", "sha1": "pshaw" },
   "unstable": { "dist": "pair", "version": "0.0.2a1", "sha1": "pshaw" },
   "versions": {
      "0.2.4": [
         { "dist": "pair", "version": "0.0.3" },
         { "dist": "pair", "version": "0.0.2" }
      ],
      "0.2.3": [
         { "dist": "pair", "version": "0.0.2a1", "status": "unstable" }
      ],
      "0.2.2": [
         { "dist": "pair", "version": "0.0.1", "status": "testing" }
      ]
   }
}
'),
        ('trip', '{
   "extension": "trip",
   "latest": "stable",
   "stable": { "dist": "pair", "version": "0.0.3", "sha1": "rickshaw" },
   "testing": { "dist": "pair", "version": "0.0.1", "sha1": "pshaw" },
   "unstable": { "dist": "pair", "version": "0.0.2a1", "sha1": "pshaw" },
   "versions": {
      "0.2.5": [
         { "dist": "pair", "version": "0.0.3" },
         { "dist": "trip", "version": "0.2.5" }
      ],
      "0.2.3": [
         { "dist": "pair", "version": "0.0.2" }
      ],
      "0.2.2": [
         { "dist": "pair", "version": "0.0.2a1", "status": "unstable" }
      ],
      "0.2.1": [
         { "dist": "pair", "version": "0.0.1", "status": "testing" }
      ]
   }
}
')
    $$,
    'Should get proper data with duplicate extension versions'
);


/****************************************************************************/
-- Test dist_json().

SELECT has_function(    'dist_json' );
SELECT has_function(    'dist_json', ARRAY['text'] );
SELECT function_returns('dist_json', ARRAY['text'], 'text' );
SELECT function_lang_is('dist_json', ARRAY['text'], 'sql' );
SELECT volatility_is(   'dist_json', ARRAY['text'], 'stable' );
SELECT is_strict(       'dist_json', ARRAY['text'] );
SELECT ok(
    has_function_privilege('pgxn', 'dist_json(text)', 'EXECUTE'),
    'User "pgxn" should have EXECUTE priv on dist_json()'
);

SELECT is(
    dist_json(NULL), NULL,
    'Should get NULL value from dist_json() for NULL distribution'
);

SELECT is(
    dist_json('nothing'), NULL,
    'Should get NULL value from dist_json() for non-existent distribution'
);

-- Set up created_ats we can expect.
UPDATE distributions
   SET created_at = '2011-03-10T20:31:57'
 WHERE name = 'pair' AND version = '0.0.3';
UPDATE distributions
   SET created_at = '2011-02-22T20:31:57'
 WHERE name = 'pair' AND version = '0.0.2';
UPDATE distributions
   SET created_at = '2011-02-10T18:31:57'
 WHERE name = 'pair' AND version = '0.0.1';
UPDATE distributions
   SET created_at = '2011-02-15T18:31:57'
 WHERE name = 'pair' AND version = '0.0.2a1';

SELECT is(
    dist_json('pair'), '{
   "name": "pair",
   "releases": {
      "stable": [
         {"version": "0.0.3", "date": "2011-03-10T20:31:57Z"},
         {"version": "0.0.2", "date": "2011-02-22T20:31:57Z"}
      ],
      "testing": [
         {"version": "0.0.1", "date": "2011-02-10T18:31:57Z"}
      ],
      "unstable": [
         {"version": "0.0.2a1", "date": "2011-02-15T18:31:57Z"}
      ]
   }
}
', 'Should get expected JSON for distribution "pair"');

SELECT json_ok(dist_json('pair'), '...And the JSON should be valid');

-- Add version 0.0.10.
SELECT lives_ok(
     $$ SELECT * FROM add_distribution('theory', 'pshaw', '{
        "name": "pair",
        "version": "0.0.10",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Ordered pair",
        "provides": {
            "pair": { "file": "pair.sql.in", "version": "0.02.10" },
            "trip": { "file": "trip.sql.in", "version": "0.02.10" }
        }
    }') $$,
    'Add a stable distribution pair 0.0.10'
);

UPDATE distributions
   SET created_at = '2011-03-11T20:36:48Z'
 WHERE name = 'pair' AND version = '0.0.10';

SELECT is(
    dist_json('pair'), '{
   "name": "pair",
   "releases": {
      "stable": [
         {"version": "0.0.10", "date": "2011-03-11T20:36:48Z"},
         {"version": "0.0.3", "date": "2011-03-10T20:31:57Z"},
         {"version": "0.0.2", "date": "2011-02-22T20:31:57Z"}
      ],
      "testing": [
         {"version": "0.0.1", "date": "2011-02-10T18:31:57Z"}
      ],
      "unstable": [
         {"version": "0.0.2a1", "date": "2011-02-15T18:31:57Z"}
      ]
   }
}
', '0.0.10 should be greater than 0.0.3 in the "pair" JSON');

SELECT json_ok(dist_json('pair'), '...And that JSON should be valid');

UPDATE distributions
   SET created_at = '2011-02-11T20:36:48Z'
 WHERE name = 'trip' AND version = '0.2.5';

-- Select another distribution.
SELECT is(
    dist_json('trip'), '{
   "name": "trip",
   "releases": {
      "stable": [
         {"version": "0.2.5", "date": "2011-02-11T20:36:48Z"}
      ]
   }
}
', 'Should get expected JSON for distribution "trip"');

SELECT json_ok(dist_json('trip'), '...And its JSON should be valid');

/****************************************************************************/
-- Test tag_json().

SELECT has_function(    'tag_json' );
SELECT has_function(    'tag_json', ARRAY['text', 'semver'] );
SELECT function_returns('tag_json', ARRAY['text', 'semver'], 'setof record' );
SELECT function_lang_is('tag_json', ARRAY['text', 'semver'], 'sql' );
SELECT volatility_is(   'tag_json', ARRAY['text', 'semver'], 'stable' );
SELECT is_strict(       'tag_json', ARRAY['text', 'semver'] );
SELECT ok(
    has_function_privilege('pgxn', 'tag_json(text, semver)', 'EXECUTE'),
    'User "pgxn" should have EXECUTE priv on tag_json()'
);

SELECT is_empty(
    $$ SELECT * FROM tag_json(NULL, NULL) $$,
    'Should get no results from tag_json() when no tags'
);

-- We'll need some tags.
INSERT INTO distribution_tags
VALUES
       -- foo for all.
       ('pair', '0.0.1',   'foo'),
       ('pair', '0.0.2a1', 'foo'),
       ('pair', '0.0.2',   'foo'),
       ('trip', '0.2.5',   'foo'),
       ('pair', '0.0.10',  'foo'),

       -- bar for two latest pairs.
       ('pair', '0.0.2',   'bar'),
       ('pair', '0.0.10',  'bar')
;

SELECT is_empty(
    $$ SELECT * FROM tag_json('foo', '1.1.1') $$,
    'Should get no results from tag_json() for non-existent distribution'
);

-- Check distribution with one tag.
SELECT results_eq(
    $$ SELECT * FROM tag_json('trip', '0.2.5') $$,
    $$ VALUES ('foo'::citext, '{
   "tag": "foo",
   "releases": {
      "pair": {
         "stable": [
            {"version": "0.0.10", "date": "2011-03-11T20:36:48Z"},
            {"version": "0.0.2", "date": "2011-02-22T20:31:57Z"}
         ],
         "testing": [
            {"version": "0.0.1", "date": "2011-02-10T18:31:57Z"}
         ],
         "unstable": [
            {"version": "0.0.2a1", "date": "2011-02-15T18:31:57Z"}
         ]
      },
      "trip": {
         "stable": [
            {"version": "0.2.5", "date": "2011-02-11T20:36:48Z"}
         ]
      }
   }
}
') $$, 'Should have proper JSON for single-tag distribution');

-- Add another tag to the "trip" distribution.
INSERT INTO distribution_tags VALUES('trip', '0.2.5', 'baz');
SELECT results_eq(
    $$ SELECT * FROM tag_json('trip', '0.2.5') ORDER BY tag $$,
    $$ VALUES ('baz'::citext, '{
   "tag": "baz",
   "releases": {
      "trip": {
         "stable": [
            {"version": "0.2.5", "date": "2011-02-11T20:36:48Z"}
         ]
      }
   }
}
'), ('foo', '{
   "tag": "foo",
   "releases": {
      "pair": {
         "stable": [
            {"version": "0.0.10", "date": "2011-03-11T20:36:48Z"},
            {"version": "0.0.2", "date": "2011-02-22T20:31:57Z"}
         ],
         "testing": [
            {"version": "0.0.1", "date": "2011-02-10T18:31:57Z"}
         ],
         "unstable": [
            {"version": "0.0.2a1", "date": "2011-02-15T18:31:57Z"}
         ]
      },
      "trip": {
         "stable": [
            {"version": "0.2.5", "date": "2011-02-11T20:36:48Z"}
         ]
      }
   }
}
') $$, 'Should have proper JSON for double-tag distribution');

SELECT json_ok(json, 'JSON for tag ' || tag || ' should be valid')
  FROM tag_json('trip', '0.2.5');

SELECT is_empty(
    $$ SELECT * FROM tag_json('dowop', '9.50.1') $$,
    'Should get no results from tag_json() for invalid version'
);

-- Now see how things look for pair's tags.
SELECT results_eq(
    $$ SELECT * FROM tag_json('pair', '0.0.1') ORDER BY tag $$,
    $$ VALUES ('foo'::citext, '{
   "tag": "foo",
   "releases": {
      "pair": {
         "stable": [
            {"version": "0.0.10", "date": "2011-03-11T20:36:48Z"},
            {"version": "0.0.2", "date": "2011-02-22T20:31:57Z"}
         ],
         "testing": [
            {"version": "0.0.1", "date": "2011-02-10T18:31:57Z"}
         ],
         "unstable": [
            {"version": "0.0.2a1", "date": "2011-02-15T18:31:57Z"}
         ]
      },
      "trip": {
         "stable": [
            {"version": "0.2.5", "date": "2011-02-11T20:36:48Z"}
         ]
      }
   }
}
') $$, 'Should have proper JSON for early version of pair');

SELECT results_eq(
    $$ SELECT * FROM tag_json('pair', '0.0.10') ORDER BY tag $$,
    $$ VALUES ('bar'::citext, '{
   "tag": "bar",
   "releases": {
      "pair": {
         "stable": [
            {"version": "0.0.10", "date": "2011-03-11T20:36:48Z"},
            {"version": "0.0.2", "date": "2011-02-22T20:31:57Z"}
         ]
      }
   }
}
'), ('foo'::citext, '{
   "tag": "foo",
   "releases": {
      "pair": {
         "stable": [
            {"version": "0.0.10", "date": "2011-03-11T20:36:48Z"},
            {"version": "0.0.2", "date": "2011-02-22T20:31:57Z"}
         ],
         "testing": [
            {"version": "0.0.1", "date": "2011-02-10T18:31:57Z"}
         ],
         "unstable": [
            {"version": "0.0.2a1", "date": "2011-02-15T18:31:57Z"}
         ]
      },
      "trip": {
         "stable": [
            {"version": "0.2.5", "date": "2011-02-11T20:36:48Z"}
         ]
      }
   }
}
') $$, 'Should have proper JSON for later version of pair');

SELECT json_ok(json, 'JSON for tag ' || tag || ' should be valid')
  FROM tag_json('pair', '0.0.10');

-- Insert a new distribution with no tags.
SELECT lives_ok(
     $$ SELECT * FROM add_distribution('theory', 'pshaw', '{
        "name": "duwop",
        "version": "0.50.1",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Do wa, p-diddy"
    }') $$,
    'Add another distribution'
);

-- Check tags for distribution with no tags.
SELECT is_empty(
    $$ SELECT * FROM tag_json('dowop', '0.50.1') $$,
    'Should get no results from tag_json() for tagless distribution'
);

/****************************************************************************/
-- Test user_json().

SELECT has_function(    'user_json' );
SELECT has_function(    'user_json', ARRAY['label'] );
SELECT function_returns('user_json', ARRAY['label'], 'text' );
SELECT function_lang_is('user_json', ARRAY['label'], 'sql' );
SELECT volatility_is(   'user_json', ARRAY['label'], 'stable' );
SELECT is_strict(       'user_json', ARRAY['label'] );
SELECT ok(
    has_function_privilege('pgxn', 'user_json(label)', 'EXECUTE'),
    'User "pgxn" should have EXECUTE priv on user_json()'
);

SELECT is(
    user_json(NULL), NULL,
    'Should get NULL value from user_json() for NULL nickname'
);

SELECT is(
    user_json('nobody'), NULL,
    'Should get NULL value from user_json() for non-existent user'
);

-- Insert a new user who will have no distributions.
SELECT ok(
    insert_user('anna', 'wet blanket', email := 'anna@pgxn.org'),
    'Insert user "anna"'
);

SELECT is(
    user_json('anna'),
    '{
   "nickname": "anna",
   "name": "",
   "email": "anna@pgxn.org"
}
',
    'Should get proper JSON for user without distribution or URI'
);

SELECT json_ok(user_json('anna'), '...And that JSON should be valid');

-- See about user with one distribution.
SELECT is(
    user_json('strongrrl'),
    '{
   "nickname": "strongrrl",
   "name": "",
   "email": "strongrrl@pgxn.org",
   "twitter": "strongrrl",
   "releases": {
      "trip": {
         "stable": [
            {"version": "0.2.5", "date": "2011-02-11T20:36:48Z"}
         ]
      }
   }
}
',
    'Should get proper JSON for user with one distribution'
);

SELECT json_ok(user_json('strongrrl'), '...And that JSON should be valid');

UPDATE distributions
   SET created_at = '2011-02-13T02:43:03'
 WHERE name = 'duwop' AND version = '0.50.1';

-- See about user with many distributions.
SELECT is(
    user_json('theory'),
    '{
   "nickname": "theory",
   "name": "",
   "email": "theory@pgxn.org",
   "uri": "http://justatheory.com/",
   "releases": {
      "duwop": {
         "stable": [
            {"version": "0.50.1", "date": "2011-02-13T02:43:03Z"}
         ]
      },
      "pair": {
         "stable": [
            {"version": "0.0.10", "date": "2011-03-11T20:36:48Z"},
            {"version": "0.0.3", "date": "2011-03-10T20:31:57Z"},
            {"version": "0.0.2", "date": "2011-02-22T20:31:57Z"}
         ],
         "testing": [
            {"version": "0.0.1", "date": "2011-02-10T18:31:57Z"}
         ],
         "unstable": [
            {"version": "0.0.2a1", "date": "2011-02-15T18:31:57Z"}
         ]
      }
   }
}
',
    'Should get proper JSON for user with many distributions'
);

SELECT json_ok(user_json('theory'), '...And that JSON should be valid');

SELECT * FROM finish();
ROLLBACK;
